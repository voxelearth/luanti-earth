<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Luanti Earth – Voxel Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Tailwind (simple UI) -->
  <link
    href="https://unpkg.com/tailwindcss@1.9.6/dist/tailwind.min.css"
    rel="stylesheet"
  />

  <!-- Three.js via import map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #050505;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100">
  <!-- UI panel -->
  <div class="fixed top-4 left-4 z-20 w-80">
    <div class="bg-gray-900 bg-opacity-90 border border-gray-700 rounded-xl shadow-xl p-4">
      <h1 class="text-lg font-semibold text-teal-300 mb-1">
        Luanti Earth – Voxel Viewer
      </h1>
      <p class="text-xs text-gray-400 mb-3">
        Paste <code class="text-yellow-300">voxels.json</code> and click
        <span class="font-semibold text-teal-200">Visualize</span>.
      </p>

      <textarea
        id="jsonInput"
        class="w-full h-32 text-xs font-mono bg-gray-800 border border-gray-700 rounded-md p-2 resize-none focus:outline-none focus:border-teal-400"
        placeholder='{"voxels":[{"x":0,"y":0,"z":0,"r":255,"g":0,"b":0,"a":255}, ...]}'
      ></textarea>

      <div class="flex flex-wrap items-center gap-2 mt-3">
        <button
          id="btnVisualize"
          class="px-3 py-1.5 text-xs font-semibold rounded-md bg-teal-500 hover:bg-teal-400 text-gray-900 focus:outline-none"
        >
          Visualize
        </button>

        <button
          id="btnReset"
          class="px-3 py-1.5 text-xs rounded-md bg-gray-700 hover:bg-gray-600 text-gray-100 focus:outline-none"
        >
          Reset Camera
        </button>

        <button
          id="btnWireframe"
          class="px-3 py-1.5 text-xs rounded-md bg-gray-700 hover:bg-gray-600 text-gray-100 focus:outline-none"
        >
          Wireframe: Off
        </button>
      </div>

      <div
        id="status"
        class="mt-3 text-xs px-2 py-1 rounded bg-gray-800 border border-gray-700 text-gray-300"
      >
        Ready.
      </div>
    </div>
  </div>

  <!-- 3D Scene -->
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { mergeGeometries } from "three/addons/utils/BufferGeometryUtils.js";

    let scene, camera, renderer, controls;
    let voxelsMesh = null;
    let wireframe = false;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202020); // lighter so dark greys show up

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(40, 30, 40);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.NoToneMapping;
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 5;
      controls.maxDistance = 800;

      // Lights for lit shading (normals matter)
      const hemi = new THREE.HemisphereLight(0xffffff, 0x111111, 0.6);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(40, 60, 20);
      scene.add(dir);

      const dir2 = new THREE.DirectionalLight(0x88aaff, 0.3);
      dir2.position.set(-30, 40, -20);
      scene.add(dir2);

      // Grid + axes
      const grid = new THREE.GridHelper(200, 40, 0x444444, 0x222222);
      scene.add(grid);
      const axes = new THREE.AxesHelper(5);
      scene.add(axes);

      window.addEventListener("resize", onWindowResize);

      document.getElementById("btnVisualize").addEventListener("click", loadFromTextarea);
      document.getElementById("btnReset").addEventListener("click", resetCamera);
      document.getElementById("btnWireframe").addEventListener("click", toggleWireframe);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // -------- UI: load + visualize ----------
    function loadFromTextarea() {
      const status = document.getElementById("status");
      const input = document.getElementById("jsonInput").value.trim();

      if (!input) {
        status.textContent = "⚠ Paste JSON first.";
        status.className =
          "mt-3 text-xs px-2 py-1 rounded bg-yellow-900 border border-yellow-700 text-yellow-200";
        return;
      }

      let voxels;
      try {
        const data = JSON.parse(input);
        voxels = Array.isArray(data) ? data : data.voxels;
        if (!voxels || !Array.isArray(voxels)) {
          throw new Error("Expected array or object with `voxels` array.");
        }
      } catch (e) {
        status.textContent = "❌ JSON error: " + e.message;
        status.className =
          "mt-3 text-xs px-2 py-1 rounded bg-red-900 border border-red-700 text-red-200";
        return;
      }

      console.log("Sample voxels:", voxels.slice(0, 5));

      const start = performance.now();
      const { boxes } = greedyMerge1DX(voxels); // still greedy along X
      const mergeTime = (performance.now() - start).toFixed(1);

      buildMergedMeshFromBoxes(boxes);

      status.textContent =
        "✅ " +
        boxes.length +
        " boxes (" +
        voxels.length +
        " voxels) – " +
        mergeTime +
        " ms.";
      status.className =
        "mt-3 text-xs px-2 py-1 rounded bg-green-900 border border-green-700 text-green-200";
    }

    // -------- Greedy merge along X (per y,z,color) ----------
    function greedyMerge1DX(voxels) {
      const groups = new Map();

      for (const v of voxels) {
        const x = v.x | 0;
        const y = v.y | 0;
        const z = v.z | 0;
        const r = v.r ?? 255;
        const g = v.g ?? 255;
        const b = v.b ?? 255;
        const a = v.a ?? 255;

        const key = `${y},${z},${r},${g},${b},${a}`;
        let arr = groups.get(key);
        if (!arr) {
          arr = [];
          groups.set(key, arr);
        }
        arr.push(x);
      }

      const boxes = [];

      for (const [key, xs] of groups.entries()) {
        if (!xs.length) continue;
        xs.sort((a, b) => a - b);

        const [yStr, zStr, rStr, gStr, bStr, aStr] = key.split(",");
        const y = parseInt(yStr, 10);
        const z = parseInt(zStr, 10);
        const r = parseInt(rStr, 10);
        const g = parseInt(gStr, 10);
        const b = parseInt(bStr, 10);
        const a = parseInt(aStr, 10);

        let runStart = xs[0];
        let prev = xs[0];

        for (let i = 1; i <= xs.length; i++) {
          const curr = xs[i];
          if (curr !== prev + 1) {
            const length = prev - runStart + 1;
            const centerX = runStart + (length - 1) / 2;
            boxes.push({
              x: centerX,
              y,
              z,
              sx: length,
              sy: 1,
              sz: 1,
              r,
              g,
              b,
              a
            });
            runStart = curr;
          }
          prev = curr;
        }
      }

      return { boxes };
    }

    // -------- Build merged geometry with correct normals ----------
    function buildMergedMeshFromBoxes(boxes) {
      if (voxelsMesh) {
        scene.remove(voxelsMesh);
        voxelsMesh.geometry.dispose();
        voxelsMesh.material.dispose();
        voxelsMesh = null;
      }

      if (!boxes.length) return;

      const geoms = [];
      let minX = Infinity, minY = Infinity, minZ = Infinity;
      let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

      for (const box of boxes) {
        const { x, y, z, sx, sy, sz, r, g, b } = box;

        // Base box with correct indices + normals
        const gBox = new THREE.BoxGeometry(sx, sy, sz);

        // Assign vertex colors (same color per vertex for this box)
        const count = gBox.attributes.position.count;
        const colors = new Float32Array(count * 3);
        const c = new THREE.Color(r / 255, g / 255, b / 255);
        for (let i = 0; i < count; i++) {
          colors[i * 3 + 0] = c.r;
          colors[i * 3 + 1] = c.g;
          colors[i * 3 + 2] = c.b;
        }
        gBox.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        // Move box to its position (centered)
        gBox.translate(x, y, z);

        geoms.push(gBox);

        const bxMin = x - sx / 2;
        const bxMax = x + sx / 2;
        const byMin = y - sy / 2;
        const byMax = y + sy / 2;
        const bzMin = z - sz / 2;
        const bzMax = z + sz / 2;

        if (bxMin < minX) minX = bxMin;
        if (byMin < minY) minY = byMin;
        if (bzMin < minZ) minZ = bzMin;
        if (bxMax > maxX) maxX = bxMax;
        if (byMax > maxY) maxY = byMax;
        if (bzMax > maxZ) maxZ = bzMax;
      }

      // Merge all box geometries into one
      const merged = mergeGeometries(geoms, false);
      merged.computeBoundingBox();
      merged.computeVertexNormals(); // normals now correct and smooth-ish

      const material = new THREE.MeshStandardMaterial({
        vertexColors: true,
        wireframe: wireframe,
        metalness: 0.0,
        roughness: 0.85
      });

      voxelsMesh = new THREE.Mesh(merged, material);
      scene.add(voxelsMesh);

      // Center camera on merged bounds
      const bbox = merged.boundingBox;
      const cx = (bbox.min.x + bbox.max.x) / 2;
      const cy = (bbox.min.y + bbox.max.y) / 2;
      const cz = (bbox.min.z + bbox.max.z) / 2;
      const size = Math.max(
        bbox.max.x - bbox.min.x,
        bbox.max.y - bbox.min.y,
        bbox.max.z - bbox.min.z,
        1
      );
      const distance = size * 1.8;

      controls.target.set(cx, cy, cz);
      camera.position.set(cx + distance, cy + distance * 0.6, cz + distance);
      controls.update();
    }

    // -------- Camera helpers ----------
    function resetCamera() {
      if (!voxelsMesh) return;
      controls.reset();
    }

    function toggleWireframe() {
      wireframe = !wireframe;
      const btn = document.getElementById("btnWireframe");
      btn.textContent = "Wireframe: " + (wireframe ? "On" : "Off");
      if (voxelsMesh) {
        voxelsMesh.material.wireframe = wireframe;
      }
    }
  </script>
</body>
</html>
